<!DOCTYPE html>
<html>
  <head>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/super-hands@^3.0.3/dist/super-hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/n5ro/aframe-physics-system@59100ac/dist/aframe-physics-system.js"></script>
    <script src="https://unpkg.com/aframe-physics-extras/dist/aframe-physics-extras.min.js"></script>
    <script src="https://unpkg.com/aframe-event-set-component@^4.1.1/dist/aframe-event-set-component.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.1/dist/aframe-environment-component.min.js"></script>
  </head>
  <body onload="myOnLoad(event)">
    <a-scene background="color: #ECECEC" stats2
    physics="gravity: 0"
    >
        <a-assets>
            <!-- <a-asset-item id="plot_gltf" src="data.gltf"></a-asset-item> -->
            <a-mixin id="hand-controller"
              physics-collider="ignoreSleep: true"
              collision-filter="collisionForces: false"
              static-body="shape: sphere; sphereRadius: 0.02"
              super-hands="colliderEvent: collisions;
                          colliderEventProperty: els;
                          colliderEndEvent: collisions;
                          colliderEndEventProperty: clearedEls;
                          grabStartButtons: gripdown;
                          grabEndButtons: gripup;
                          stretchStartButtons: gripdown;
                          stretchEndButtons: gripup;
                          "
            ></a-mixin>
            <a-mixin id="grabbable-component"
              dynamic-body="shape: box; mass: 10000"
              collision-filter="collisionForces: false"
              sleepy
              stretchable
              grabbable
              grabbable2="startButtons: ['gripdown']; endButtons: ['gripup']"
            ></a-mixin>

        </a-assets>
        <!-- show light also in AR -->
        <a-entity class="environment" position="0 50 0" light="groundColor:#f0e9fb;intensity:0.6;color:#beaeda;type:hemisphere"></a-entity>
        <a-entity class="environment" position="-1.33 1 0.24" light="shadowCameraLeft:-10;shadowCameraBottom:-10;shadowCameraRight:10;shadowCameraTop:10;intensity:0.6"></a-entity>
        <!-- rest of env only show in VR -->
        <a-entity environment="preset: japan; groundColor: #f0e9fb; lighting: none" hide-on-enter-ar id="environment"></a-entity>
        
        <a-entity>
            <a-camera id="camera"
            ></a-camera>
            <a-entity hand-controls="hand: left" mixin="hand-controller"></a-entity>
            <a-entity hand-controls="hand: right" mixin="hand-controller" ></a-entity>
        </a-entity>
        <a-entity id="models_group" position="0 1.1 -1.1">
          <!-- <a-box color="lightgray" scale="0.5 0.5 0.5" id="stand"
              position="0 0.85 -1.1" position2="0 -.25 0"
              dynamic-body="shape: box"
              visible="false"
              collision-filter="collisionForces: false"
              grabbable
              grabbable2="startButtons: ['gripdown']; endButtons: ['gripup']"
              hoverable
              event-set__hoveron="_event: hover-start; material.opacity: 0.7; transparent: true"
              event-set__hoveroff="_event: hover-end; material.opacity: 1; transparent: false"
              event-set__grabon="_event:  grab-start; material.color: green"
              event-set__graboff="_event: grab-end; material.color: lightgray"
            ></a-box> -->
            <!-- gltf-model="data.gltf"  -->
            <a-entity position="0 0.5 0" scale="5 5 5" id="model"
              title="Plot"
              mixin="grabbable-component"
              animation-mixer=""
              ></a-entity>
        </a-entity>
    </a-scene>
  </body>
  <script>
    // let scene = document.getElementsByName
    var playerEl = document.querySelector('#model');
    playerEl.addEventListener('model-loaded', function (e) {
      console.log('model-loaded:',e)
    })
    playerEl.addEventListener('model-error', function (e) {
      console.log('model-error:',e)
    })
    playerEl.addEventListener('collide', function (e) {
      // console.log('stand has collided with body #' + e.detail.id);
      // console.log(e.detail.body);

      // e.detail.target.el;  // Original entity (playerEl).
      // e.detail.body.el;    // Other entity, which playerEl touched.
      // e.detail.contact;    // Stats about the collision (CANNON.ContactEquation).
      // e.detail.contact.ni; // Normal (direction) of the collision (CANNON.Vec3).
    });

    // const loggingEl = document.getElementById("logging");
    function log(...text){
      console.log('log', text)
      // loggingEl.setAttribute("value", 'Logging:' + text.join(" "));
    }
    const envEl = document.getElementById("environment")
    document.querySelectorAll('[hand-controls]').forEach(el => {
      log('hc', el)

      let events = ['abuttondown','xbuttondown'];
      for (let i=0; i<events.length; i++)
        el.addEventListener(events[i], function(e){
          log("buttondown")
          console.log('hand-event',events[i], e)
          // toggle visibility if in AR
          if (envEl.sceneEl.is('ar-mode')) {
            envEl.object3D.visible = ! envEl.object3D.visible;
            log("toggling visible, now "+envEl.object3D.visible);
          }
        })
    })

    var queryParams = null;

    function getQueryParams(){
      if(queryParams == null){
        queryParams = {};
        if(location.search.length==0){
          return queryParams;
        }
        var vars = location.search.substring(1).split("&");
        for(var i=0; i<vars.length; i++){
          var index = vars[i].indexOf("=")
          if(index > 0){
            var name = vars[i].substring(0,index).split("+").join(" ");
            var value = vars[i].substring(index+1).split("+").join(" ");
            queryParams[decodeURIComponent(name)] = decodeURIComponent(value);
          }
        }
        log(queryParams)
      }
      return queryParams;
    }
    function findServer(){
      var ret = getQueryParams().server;
      if(ret != null)
        return ret;
      // if we got here from a server, use it:
      return new URL("index.html", location).href;
    }
    function findWsUrl(){
      var ret = getQueryParams().wsUrl;
      if(ret != null)
        return ret;
      ret = new URL("ws", server);
      ret.protocol = (ret.protocol == "https:") ? "wss:" : "ws:";
      console.log("found WsUrl: "+ret)
      return ret;
    }

    var connected = false;
    var server = findServer();
    var wsUrl = findWsUrl();
    var websocket = null;

    function openTheWebsocket(wsUrl){
      if(wsUrl == null)
        return;
      try{
        websocket = new WebSocket(wsUrl);

        websocket.onopen = function() {
          sendMessage({'controller': true})
          updateFocus();
        }
        websocket.onmessage = function(msg) {
          if(msg.data.length == 0)
            return;
          log("Got message: "+msg.data);
          var body = JSON.parse(msg.data)
          if('status' in body){
            state = body['status']
            for(key in state){
              el = document.getElementById("status_"+key)
              if(el)
                el.innerHTML = state[key];
            }
          }
          if("key" in body){
            handle_char(body["key"]);
          }
          //websocket.send("thanks");
        }
        websocket.onclose = function(event){
          log('websocket closed.')
        }

        connected = true;
      }catch(err){
        log(err);
      }
    }
    var revision = 0;
    function update_model(){
      console.log("Updating model")
      let m = document.getElementById("model")
      let url = new URL("data.gltf?revision=" + (revision++), server)
      m.setAttribute("gltf-model", url.toString())
      // let asset = document.getElementById("plot_gltf")
      // asset.setAttribute("src", url.toString())
    }
    function handle_char(msg){
      if(msg == "r"){
        // we need to close the websocket, else on Chrome (Android/Linux/macOS)
        // this somehow backfires and httpuv in the R-session crashes with segfault
        if(websocket != null){
          closeWebSocket();
          location.reload(true);
        }else{
          location.reload(true);
        }
        return;
      }else if(msg == "reload_data" || msg =="x" ){
        update_model()
      //  refreshData();
      // }else if(msg === "c"){
      //   websocket.close();
      //   return;
      }else if(msg === "space"){
        speed = (speed==0) ? 1 : 0;
        log("New speed: "+speed);
/*      }else if(msg === "f"){
        toggleFullscreen();
      }else if(msg === "c"){
        if(connected){
          device_controls.disconnect();
        }else{
          device_controls.connect();
        }
        connected = !connected;*/
      }else{
        var ALPHA_ROT = 0.1;
        if(msg === "a"){
          go(-1, 0, 0);
        }else if(msg === "d"){
          go(1, 0, 0);
        }else if(msg === "s"){
          go(0, 0, 1);
        }else if(msg === "w"){
          go(0, 0, -1);
        }else if(msg === "q"){
          go(0, 1, 0);
        }else if(msg === "e"){
          go(0, -1, 0);
        }else if(msg === "Left"){
          camera.rotateY(ALPHA_ROT);
        }else if(msg === "Right"){
          camera.rotateY(-ALPHA_ROT);
        }else if(msg === "Up"){
          camera.rotateX(ALPHA_ROT);
        }else if(msg === "Down"){
          camera.rotateX(-ALPHA_ROT);
        }
      }
    }

    function getKeyChar(key){
      var keychar = String.fromCharCode(key).toLowerCase();
      if(key==32){
        keychar = "space";
      }else if(key==37){
        keychar = "Left";
      }else if(key==38){
        keychar = "Up";
      }else if(key==39){
        keychar = "Right";
      }else if(key==40){
        keychar = "Down";
      }
      console.log(keychar)
      return keychar
    }

    function updateFocus(event){
    //   log("Update Focus upon: " + event);
    //   focusWidget = document.getElementById("focusWidget");
    //   keyboard = document.getElementById("keyboard");
      if(document.hasFocus()){
        // focusWidget.innerHTML = "has focus";
        // keyboard.className = "focused";
        // document.getElementById("focusBox").style.display = 'none'
        sendMessage({'focus': true});
      }else{
        // focusWidget.innerHTML = "has not focus";
        // keyboard.className = "blured";
        // document.getElementById("focusBox").style.display = 'block'
        sendMessage({'focus': false});
      }
      // if(websocket==null || websocket.readyState != WebSocket.OPEN)
      //   keyboard.className = "disconnected";
    //   log(keyboard.className)
    }

    function sendMessage(message){
      if(typeof(message) === 'string' || message instanceof String){
        message = { "message": message }
      }
      message = JSON.stringify(message)
      if(websocket != null && websocket.readyState == WebSocket.OPEN){
        websocket.send(message);
        log('sent message: ' + message);
      }else{
        log('no websocket - would have sent message: ' + message);
      }
    }

    function closeWebSocket(){
      if(websocket != null){
        // sendMessage("byebye")
        websocket.close();
        websocket = null;
      }
    }

    function myOnLoad(event){
      update_model()
      openTheWebsocket(wsUrl);

      updateFocus(event);
    }

    function log(msg){
      console.log(msg)
      // debugWidget = document.getElementById("debug");
      // debugWidget.innerHTML += msg+"\n";
    }

  </script>
</html>
